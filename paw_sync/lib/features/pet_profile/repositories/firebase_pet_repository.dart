// lib/features/pet_profile/repositories/firebase_pet_repository.dart

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:paw_sync/core/utils/constants.dart'; // Import constants
import 'package:paw_sync/features/pet_profile/models/pet_model.dart';
import 'package:paw_sync/features/pet_profile/repositories/pet_repository.dart';

class FirebasePetRepository implements PetRepository {
  final FirebaseFirestore _firestore;
  // static const String petsCollectionPath = 'pets'; // Replaced by kPetsCollection

  FirebasePetRepository(this._firestore);

  CollectionReference<Pet> get _petsCollection =>
      _firestore.collection(kPetsCollection).withConverter<Pet>( // Use constant
            fromFirestore: (snapshot, _) => Pet.fromJson(snapshot.data()!),
            toFirestore: (pet, _) => pet.toJson(),
          );

  @override
  Future<void> addPet(Pet pet) async {
    try {
      // If pet ID is meant to be generated by Firestore, ensure it's not set or handle accordingly.
      // For this example, we assume pet.id might be pre-generated (e.g., UUID on client)
      // or Firestore will generate one if document path is not specified.
      // If using .add(), Firestore generates the ID. If using .doc(id).set(), ID is client-provided.
      // Let's assume client provides ID for now, or use .add() if ID should be auto-generated.
      // If pet.id is empty, use .add() to let Firestore generate it. Otherwise, use .doc(pet.id).set().
      if (pet.id.isEmpty) {
         final docRef = await _petsCollection.add(pet);
         // Optionally update the pet object with the Firestore-generated ID if needed by the caller
         // This would require the method to return Pet or Future<Pet>.
         // For void, the caller might need to re-fetch or handle ID separately.
         print('Pet added with Firestore-generated ID: ${docRef.id}');
      } else {
        await _petsCollection.doc(pet.id).set(pet);
      }
    } on FirebaseException catch (e) {
      throw PetRepositoryException('Failed to add pet: ${e.message}', e.code, e);
    } catch (e) {
      throw PetRepositoryException('An unexpected error occurred while adding pet.', null, e);
    }
  }

  @override
  Future<void> deletePet(String petId) async {
    try {
      await _petsCollection.doc(petId).delete();
    } on FirebaseException catch (e) {
      throw PetRepositoryException('Failed to delete pet: ${e.message}', e.code, e);
    } catch (e) {
      throw PetRepositoryException('An unexpected error occurred while deleting pet.', null, e);
    }
  }

  @override
  Future<Pet?> getPetById(String petId) async {
    try {
      final docSnapshot = await _petsCollection.doc(petId).get();
      if (docSnapshot.exists) {
        return docSnapshot.data();
      }
      return null;
    } on FirebaseException catch (e) {
      throw PetRepositoryException('Failed to get pet by ID: ${e.message}', e.code, e);
    } catch (e) {
      throw PetRepositoryException('An unexpected error occurred while fetching pet by ID.', null, e);
    }
  }

  @override
  Future<List<Pet>> getPets(String ownerId) async {
    try {
      final querySnapshot = await _petsCollection
          .where('ownerId', isEqualTo: ownerId)
          .get();
      return querySnapshot.docs.map((doc) => doc.data()).toList();
    } on FirebaseException catch (e) {
      throw PetRepositoryException('Failed to get pets for owner: ${e.message}', e.code, e);
    } catch (e) {
      throw PetRepositoryException('An unexpected error occurred while fetching pets.', null, e);
    }
  }

  @override
  Stream<List<Pet>> getPetsStream(String ownerId) {
    try {
      return _petsCollection
          .where('ownerId', isEqualTo: ownerId)
          .snapshots()
          .map((snapshot) => snapshot.docs.map((doc) => doc.data()).toList())
          .handleError((error) {
            if (error is FirebaseException) {
              throw PetRepositoryException('Error streaming pets: ${error.message}', error.code, error);
            }
            throw PetRepositoryException('An unexpected error occurred while streaming pets.', null, error);
          });
    } catch (e) {
      // Catch synchronous errors during stream setup, though most errors will be asynchronous.
      throw PetRepositoryException('Failed to set up pets stream.', null, e);
    }
  }

  @override
  Future<void> updatePet(Pet pet) async {
    try {
      // Assumption: pet.id is valid and exists.
      // Consider adding a check or let Firestore handle non-existent doc errors.
      await _petsCollection.doc(pet.id).update(pet.toJson());
    } on FirebaseException catch (e) {
      throw PetRepositoryException('Failed to update pet: ${e.message}', e.code, e);
    } catch (e) {
      throw PetRepositoryException('An unexpected error occurred while updating pet.', null, e);
    }
  }
}
